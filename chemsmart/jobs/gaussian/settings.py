import copy
import logging
import os
import re

from chemsmart.io.gaussian import GAUSSIAN_SOLVATION_MODELS
from chemsmart.io.gaussian.gengenecp import GenGenECPSection
from chemsmart.jobs.settings import MolecularJobSettings
from chemsmart.utils.periodictable import PeriodicTable

pt = PeriodicTable()


logger = logging.getLogger(__name__)


class GaussianJobSettings(MolecularJobSettings):
    def __init__(
        self,
        ab_initio=None,
        functional=None,
        basis=None,
        charge=None,
        multiplicity=None,
        chk=True,
        job_type=None,
        title=None,
        freq=False,
        numfreq=False,
        dieze_tag=None,
        solvent_model=None,
        solvent_id=None,
        additional_opt_options_in_route=None,
        additional_route_parameters=None,
        route_to_be_written=None,
        modred=None,
        gen_genecp_file=None,
        heavy_elements=None,
        heavy_elements_basis=None,
        light_elements_basis=None,
        custom_solvent=None,
        append_additional_info=None,
        forces=False,
        input_string=None,
        **kwargs,
    ):
        super().__init__(
            ab_initio=ab_initio,
            functional=functional,
            basis=basis,
            charge=charge,
            multiplicity=multiplicity,
            freq=freq,
            numfreq=numfreq,
            job_type=job_type,
            title=title,
            solvent_model=solvent_model,
            solvent_id=solvent_id,
            additional_route_parameters=additional_route_parameters,
            route_to_be_written=route_to_be_written,
            modred=modred,
            gen_genecp_file=gen_genecp_file,
            heavy_elements=heavy_elements,
            heavy_elements_basis=heavy_elements_basis,
            light_elements_basis=light_elements_basis,
            custom_solvent=custom_solvent,
            forces=forces,
            input_string=input_string,
            **kwargs,
        )
        self.chk = chk
        self.dieze_tag = dieze_tag
        self.additional_opt_options_in_route = additional_opt_options_in_route
        self.append_additional_info = append_additional_info

        if gen_genecp_file is not None and "~" in gen_genecp_file:
            gen_genecp_file = os.path.expanduser(gen_genecp_file)
        self.gen_genecp_file = gen_genecp_file

        if forces is True and freq is True:
            raise ValueError(
                "Frequency and Force calculations cannot be performed by Gaussian at the same time!\n"
                'Such an input file will give "Illegal IType or MSType generated by parse." error.'
            )

    @property
    def genecp(self):
        return (
            self.gen_genecp_file is not None or self.heavy_elements is not None
        )

    def merge(
        self,
        other,
        keywords=("charge", "multiplicity", "title"),
        merge_all=False,
    ):
        """Overwrite self settings with other settings.

        Args:
            keywords (list): Specific list of keywords to merge.
                Defaults to charge and multiplicity.
                If None, all settings will be merged (Caution: may cause issue if e.g.,
                genecp log file used to prepare input without genecp).
            other (JobSettings, dict): Settings to merge. Can also take the form of a dictionary
            merge_all (bool): If True, merge all settings.
            If False, only merge the settings specified in keywords.
        """
        other_dict = other if isinstance(other, dict) else other.__dict__

        if merge_all:
            # Update self with other for all
            merged_dict = self.__dict__.copy()
            merged_dict.update(other_dict)
            return type(self)(**merged_dict)

        if keywords is not None:
            other_dict = {
                k: other_dict[k] for k in keywords if k in other_dict
            }
        # Update self with other
        merged_dict = self.__dict__.copy()
        merged_dict.update(other_dict)
        return type(self)(**merged_dict)

    def copy(self):
        return copy.deepcopy(self)

    def __getitem__(self, key):
        return self.__dict__[key]

    def __eq__(self, other):
        """Two settings objects are equal if all their attributes are equal."""
        if type(self) is not type(other):
            return NotImplemented

        # Exclude append_additional_info from the comparison
        self_dict = self.__dict__
        self_dict.pop("append_additional_info")

        other_dict = other.__dict__
        other_dict.pop("append_additional_info")

        is_equal = self_dict == other_dict
        if not is_equal:
            import dictdiffer

            logger.info("Gaussian job settings are not equal.")
            for diff in list(dictdiffer.diff(self_dict, other_dict)):
                logger.info(f"Difference: {diff}")
        return self_dict == other_dict

    @classmethod
    def from_comfile(cls, filename):
        """Return Gaussian settings object from a given gaussian.com file.

        Args:
            filename (str): file path of the .com file string to be supplied.
        """
        from chemsmart.io.gaussian.input import Gaussian16Input

        com_path = os.path.abspath(filename)
        gaussian_settings_from_comfile = Gaussian16Input(
            filename=com_path
        ).read_settings()
        return gaussian_settings_from_comfile

    @classmethod
    def from_inpfile(cls, filename):
        """Return Gaussian settings object from a given orca.inp file.

        Args:
            filename (str): file path of the .inp file string to be supplied.
        """
        from chemsmart.io.orca.input import ORCAInput

        inp_path = os.path.abspath(filename)
        logger.info(f"Return Settings object from inp file: {inp_path}")
        orca_settings_from_inpfile = ORCAInput(
            filename=inp_path
        ).read_settings()
        gaussian_default_settings = cls.default()
        gaussian_settings_from_inpfile = gaussian_default_settings.merge(
            orca_settings_from_inpfile, merge_all=True
        )
        logger.info(
            f"with settings: {gaussian_settings_from_inpfile.__dict__}"
        )
        return gaussian_settings_from_inpfile

    @classmethod
    def from_logfile(cls, filename):
        """Return Gaussian settings object from a given gaussian.log file.

        Args:
            filename (str): file path of the .log file to be supplied.
        """
        log_path = os.path.abspath(filename)
        from chemsmart.io.gaussian.output import (
            Gaussian16Output,
            Gaussian16OutputWithPBC,
        )

        logger.info(f"Return Settings object from logfile: {log_path}")
        try:
            settings = Gaussian16Output(filename=log_path).read_settings()
        except ValueError:
            settings = Gaussian16OutputWithPBC(
                filename=log_path
            ).read_settings()

        return settings

    @classmethod
    def from_outfile(cls, filename):
        """Return Gaussian job settings from ORCA output file."""
        from chemsmart.io.orca.output import ORCAOutput

        out_path = os.path.abspath(filename)
        logger.info(
            f"Return Settings object from ORCA .out filename: {out_path}"
        )
        orca_settings_from_outfile = ORCAOutput(
            filename=out_path
        ).read_settings()
        gaussian_default_settings = cls.default()
        gaussian_settings_from_outfile = gaussian_default_settings.merge(
            orca_settings_from_outfile, merge_all=True
        )
        logger.info(
            f"with settings: {gaussian_settings_from_outfile.__dict__}"
        )
        return gaussian_settings_from_outfile

    @classmethod
    def default(cls):
        return cls(
            ab_initio=None,
            functional=None,
            basis=None,
            charge=None,
            multiplicity=None,
            chk=True,
            job_type=None,
            title="Gaussian job with default settings",
            freq=True,
            numfreq=False,
            dieze_tag=None,
            solvent_model=None,
            solvent_id=None,
            additional_opt_options_in_route=None,
            additional_route_parameters=None,
            route_to_be_written=None,
            modred=None,
            gen_genecp_file=None,
            heavy_elements=None,
            heavy_elements_basis=None,
            light_elements_basis=None,
            custom_solvent=None,
            append_additional_info=None,
            forces=False,
            input_string=None,
        )

    @classmethod
    def from_filepath(cls, filepath, **kwargs):
        if filepath.endswith((".com", ".gjf")):
            return cls.from_comfile(filepath)
        if filepath.endswith(".inp"):
            return cls.from_inpfile(filepath)
        if filepath.endswith(".log"):
            return cls.from_logfile(filepath)
        raise ValueError(f"Could not create {cls} from {filepath}")

    @property
    def route_string(self):
        if self.route_to_be_written is not None:
            route_string = self._get_route_string_from_user_input()
        else:
            route_string = self._get_route_string_from_jobtype()
        logger.debug(f"Route for settings {self}: {route_string}")
        return route_string

    def _get_route_string_from_user_input(self):
        route_string = self.route_to_be_written
        if not route_string.startswith("#"):
            route_string = (
                f"#{self.dieze_tag} {route_string}"
                if self.dieze_tag is not None
                else f"# {route_string}"
            )
        return route_string

    def get_light_elements(self, molecule):
        if self.heavy_elements is None:
            return None

        unique_atoms = set(molecule.chemical_symbols)
        light_elements_set = unique_atoms - set(self.heavy_elements)
        light_elements_list = list(light_elements_set)

        sorted_light_elements_list = pt.sorted_periodic_table_list(
            light_elements_list
        )
        logger.info(
            f"Light elements in structure: {sorted_light_elements_list}"
        )
        return sorted_light_elements_list

    def _get_route_string_from_jobtype(self):
        route_string = ""

        dieze_tag = self._get_dieze_tag()
        route_string += dieze_tag

        job_route = self._get_job_route()
        route_string += job_route

        freq_string = self._get_freq_string()
        route_string += freq_string

        level_of_theory_string = self._get_level_of_theory_string()
        route_string += level_of_theory_string

        force_string = self._get_force_string()
        route_string += force_string

        solvent_string = self._get_solvent_string()
        route_string += solvent_string

        additional_string = self._get_additional_string()
        route_string += additional_string

        return route_string

    def _get_dieze_tag(self):
        """Get dieze tag from job type."""
        route_string = ""
        if self.dieze_tag is not None:
            route_string += (
                f"#{self.dieze_tag}"  # e.g. dieze_tag='p' to get '#p'
            )
        else:
            route_string += "#"
        return route_string

    def _get_job_route(self):
        """Get route corresponding to job type."""
        route_string = ""
        # write opt with additional options e.g., maxstep, calcall etc
        if self.additional_opt_options_in_route is not None:
            if self.job_type == "opt":
                route_string += (
                    f" opt=({self.additional_opt_options_in_route})"
                )
            elif self.job_type == "ts":
                if "calcall" not in self.additional_opt_options_in_route:
                    route_string += f" opt=(ts,calcfc,noeigentest,{self.additional_opt_options_in_route})"
                else:
                    route_string += f" opt=(ts,noeigentest,{self.additional_opt_options_in_route})"
            elif self.job_type == "modred":
                route_string += f" opt=(modredundant,{self.additional_opt_options_in_route})"
            elif self.job_type == "scan":
                route_string += f" opt=(modredundant,{self.additional_opt_options_in_route})"
            elif self.job_type == "sp":
                route_string += ""
        elif self.additional_opt_options_in_route is None:
            if self.job_type == "opt":
                route_string += " opt"
            elif self.job_type == "ts":
                route_string += " opt=(ts,calcfc,noeigentest)"
            elif self.job_type == "modred":
                route_string += " opt=modredundant"
            elif self.job_type == "scan":
                route_string += " opt=modredundant"
            elif self.job_type == "sp":
                route_string += ""
        return route_string

    def _set_freq_from_job_type(self):
        """Set freq for different job type.
        Some sensible defaults have been used here."""
        if self.job_type in ["opt", "ts", "modred"]:
            self.freq = True
            self.numfreq = False
        elif self.job_type in ["sp", "scan"]:
            self.freq = False
            self.numfreq = False

    def _get_freq_string(self):
        """Get freq string for route."""
        route_string = ""
        self._set_freq_from_job_type()
        # write frequency
        if self.freq and not self.numfreq:
            route_string += " freq"
        elif not self.freq and self.numfreq:
            route_string += " freq=numer"
        elif self.freq and self.numfreq:
            raise ValueError(
                "Both freq and numfreq cannot be True at the same time!"
            )
        return route_string

    def _get_level_of_theory_string(self):
        """Get level of theory string for route."""
        route_string = ""

        if self.basis is None:
            # both ab initio and DFT functional require basis
            raise ValueError("Warning: Basis is missing!")
        if self.ab_initio is not None and self.functional is None:
            method = self.ab_initio
        elif self.ab_initio is None and self.functional is not None:
            method = self.functional
        elif self.ab_initio is not None and self.functional is not None:
            raise ValueError(
                "Warning: Both ab initio and DFT functional are provided!"
            )
        else:
            raise ValueError(
                "Warning: Both ab initio and DFT functional are missing!"
            )

        # write basis set
        route_string += f" {method} {self.basis}"

        return route_string

    def _get_force_string(self):
        """Get force string for route."""
        route_string = ""
        # write forces calculation
        if self.forces:
            route_string += " force"
        return route_string

    def _get_solvent_string(self):
        """Get solvent string for route."""
        route_string = ""
        if self.custom_solvent is not None:
            if self.solvent_model is None and self.solvent_id is None:
                route_string += (
                    " scrf=(pcm,read)"  # using pcm model as default
                )
            else:
                # Set default values if any of solvent_model or solvent_id are None
                solvent_model = self.solvent_model or "pcm"
                solvent_id = self.solvent_id or "generic,read"
                route_string += f" scrf=({solvent_model},solvent={solvent_id})"
        elif (
            self.solvent_model is not None and self.solvent_id is not None
        ):  # solvation is turned on
            route_string += (
                f" scrf=({self.solvent_model},solvent={self.solvent_id})"
            )
        elif (self.solvent_model is not None and self.solvent_id is None) or (
            self.solvent_model is None and self.solvent_id is not None
        ):  # if one is provided but the other not
            raise ValueError(
                f"Both solvent model and solvent ID need to be specified.\n"
                f"Currently, solvent model is {self.solvent_model} and solvent id is {self.solvent_id}!"
            )

        return route_string

    def _get_additional_string(self):
        """Get additional info string for route.
        Additional Route Parameters + job specific parameters."""
        route_string = ""

        # write additional parameters for route
        if self.additional_route_parameters is not None:
            route_string += f" {self.additional_route_parameters}"

        # write job type specific route
        if self.job_type == "nci":
            route_string += " output=wfn"  # output wavefunction file for NCI
        elif self.job_type == "wbi":
            route_string += " pop=nboread"  # write bond order matrix
        return route_string

    @property
    def _genecp_elements_specified(self):
        return (
            self.heavy_elements is not None
            and self.heavy_elements_basis is not None
        )

    @property
    def _genecp_file_specified(self):
        return self.gen_genecp_file is not None and os.path.exists(
            self.gen_genecp_file
        )

    def get_genecp_section(self, molecule):
        if self._genecp_elements_specified:
            logger.info(
                f"GENECP elements specified:\n"
                f"Heavy elements: {self.heavy_elements}\n"
                f"Heavy elements basis: {self.heavy_elements_basis}\n"
                f"Light elements basis: {self.light_elements_basis}\n"
            )
            # Method 1 for getting genecp
            # Need to supply self.heavy_elements, self.heavy_elements_basis
            # and self.light_elements_basis
            heavy_elements_in_structure = self.prune_heavy_elements(molecule)

            genecp_section = GenGenECPSection.from_bse_api(
                light_elements=self.get_light_elements(molecule),
                light_elements_basis=self.light_elements_basis,
                heavy_elements=heavy_elements_in_structure,
                heavy_elements_basis=self.heavy_elements_basis,
            )

        elif self._genecp_file_specified:
            logger.info(f"GENECP file specified: {self.gen_genecp_file}")
            # Method 2 for getting genecp:
            # Supplied path to genecp file
            genecp_section = GenGenECPSection.from_genecp_path(
                genecp_path=self.gen_genecp_file
            )
        else:
            raise ValueError("Could not get GenECPSection")
        return genecp_section

    def prune_heavy_elements(self, molecule):
        # heavy atoms list supplied from settings contains all heavy atoms needed for
        # heavy_atom_basis but in each structure, some heave atoms supplied from settings
        # may not appear in the structure
        if self.heavy_elements is None:
            return None
        return list(
            set(molecule.chemical_symbols).intersection(self.heavy_elements)
        )

    def _check_solvent(self, solvent_model):
        if solvent_model.lower() not in GAUSSIAN_SOLVATION_MODELS:
            raise ValueError(
                f"The specified solvent model {solvent_model} is not in \n"
                f"the available solvent models: {GAUSSIAN_SOLVATION_MODELS}"
            )


class GaussianIRCJobSettings(GaussianJobSettings):
    def __init__(
        self,
        predictor=None,
        recorrect=None,
        recalc_step=6,
        direction=None,
        maxpoints=512,
        maxcycles=128,
        stepsize=20,
        flat_irc=False,
        **kwargs,
    ):
        super().__init__(**kwargs)
        self.predictor = predictor
        self.recorrect = recorrect
        self.recalc_step = recalc_step
        self.direction = direction
        self.maxpoints = maxpoints
        self.maxcycles = maxcycles
        self.stepsize = stepsize
        self.flat_irc = flat_irc
        self.freq = False  # turn off freq calc for IRC jobs
        self.forces = False  # turn off forces calculations
        self.route_to_be_written = None

    def _get_route_string_from_jobtype(self):
        route_string = super()._get_route_string_from_jobtype()
        # if flat irc
        if self.flat_irc:
            # default route for flat IRC run if no options are specified
            self.predictor = (
                "LQA" if self.predictor is None else self.predictor
            )
            self.recorrect = (
                "never" if self.recorrect is None else self.recorrect
            )
            self.recalc_step = (
                -5 if self.recalc_step == 6 else self.recalc_step
            )

        # write job type specific route for irc
        if self.job_type == "ircf":
            self.direction = "forward"
        elif self.job_type == "ircr":
            self.direction = "reverse"

        if self.predictor is not None and self.recorrect is not None:
            route_string += (
                f" irc({self.predictor},calcfc,recorrect={self.recorrect},recalc={self.recalc_step},"
                f"stepsize={self.stepsize},{self.direction},maxpoints={self.maxpoints},maxcycle={self.maxcycles})"
            )
        elif self.predictor is None and self.recorrect is None:
            route_string += (
                f" irc(calcfc,recalc={self.recalc_step},{self.direction},"
                f"maxpoints={self.maxpoints},maxcycle={self.maxcycles})"
            )
        else:
            raise ValueError(
                f"Only one of predictor type and recorrect is specified, please check!\n"
                f"Predictor: {self.predictor}; Recorrect: {self.recorrect}"
            )

        if self.additional_route_parameters is not None:
            route_string += f" {self.additional_route_parameters}"

        return route_string


class GaussianLinkJobSettings(GaussianJobSettings):
    def __init__(
        self, link=True, link_route=None, stable="opt", guess="mix", **kwargs
    ):
        super().__init__(**kwargs)
        self.link = link
        self.link_route = link_route
        self.stable = stable
        self.guess = guess

    @property
    def link_route_string(self):
        if self.link_route is not None:
            link_route_string = self.link_route
            if self.functional not in self.link_route:
                link_route_string += f" {self.functional}"
            if self.basis not in self.link_route:
                link_route_string += f" {self.basis}"
            if "geom=check" not in self.link_route:
                link_route_string += " geom=check"
            if "guess=read" not in self.link_route:
                link_route_string += " guess=read"
            logger.debug(
                f"Link route for settings {self}: {link_route_string}"
            )
            return link_route_string

        link_route_string = self._get_link_route_string_from_jobtype()
        logger.debug(f"Link route for settings {self}: {link_route_string}")
        return link_route_string

    def _get_route_string_from_jobtype(self):
        route_string = super()._get_route_string_from_jobtype()
        # remove "opt or opt= and freq" from route string
        pattern = re.compile(r"opt\s*(=\s*(\(.*\)|\w+))?\s*", re.IGNORECASE)
        route_string_final = re.sub(pattern, "", route_string)
        route_string_final = route_string_final.replace("freq", "")
        # stable=opt guess=mix
        if self.stable:
            logger.debug(f"Stable: {self.stable}")
            route_string_final += f" stable={self.stable}"
        if self.guess:
            logger.debug(f"Guess: {self.guess}")
            route_string_final += f" guess={self.guess}"
        else:
            # other methods for link jobs - have not encountered yet,
            # but may be modified in future when needed
            pass

        return route_string_final

    def _get_link_route_string_from_jobtype(self):
        route_string = super()._get_route_string_from_jobtype()
        # remove "opt or opt= and freq" from route string

        if "geom=check" not in route_string:
            route_string += " geom=check"
        if "guess=read" not in route_string:
            route_string += " guess=read"
        return route_string


class GaussianTDDFTJobSettings(GaussianJobSettings):
    def __init__(
        self, states="singlets", root=1, nstates=3, eqsolv=None, **kwargs
    ):
        super().__init__(**kwargs)
        self.states = states
        self.root = root
        self.nstates = nstates
        self.eqsolv = eqsolv

    def _get_route_string_from_jobtype(self):
        route_string = super()._get_route_string_from_jobtype()

        if self.eqsolv is None:
            eqsolv = ""
        else:
            eqsolv_options = ["eqsolv", "noneqsolv"]
            assert (
                self.eqsolv.lower() in eqsolv_options
            ), f"Possible equilibrium solvation options are: {eqsolv_options}!"
            eqsolv = f",{self.eqsolv}"

        route_string += f" TD({self.states},nstates={self.nstates},root={self.root}{eqsolv})"

        return route_string


class GaussianQMMMJobSettings(GaussianJobSettings):

    def __init__(
        self,
        functional_high=None,
        basis_high=None,
        force_field_high=None,
        functional_medium=None,
        basis_medium=None,
        force_field_medium=None,
        functional_low=None,
        basis_low=None,
        force_field_low=None,
        high_level_charge=None,
        high_level_multiplicity=None,
        medium_level_charge=None,
        medium_level_multiplicity=None,
        low_level_charge=None,
        low_level_multiplicity=None,
        high_level_atoms=None,
        medium_level_atoms=None,
        low_level_atoms=None,
        bonded_atoms=None,
        scale_factor1=None,
        scale_factor2=None,
        scale_factor3=None,
        num_atoms=None,
        **kwargs,
    ):
        """Gaussian QM/MM Job Settings containing information to create a QM/MM Job.
        Args:
            functional_high/medium/low: Functional for high/medium/low level of theory
            basis_high/medium/low: Basis set for high/medium/low level of theory
            force_field_high/medium/low: Force field for high/medium/low level of theory (if specified)
            high/medium/low_level_charge (int): Charge for high level of theory
            high/medium/low_level_multiplicity (int): Multiplicity for high level of theory
            high_level_atoms (list or string): List of high level atoms.
            medium_level_atoms (list) : List of medium level atoms.
            low_level_atoms (list): List of low level atoms.
            bonded_atoms (list of tuples): List of bonded atoms.
            scale_factor1 (float) (optional): Scale factor for bonds between QM and MM region,default=1.0
            scale_factor2 (float) (optional): Scale factor for angles involving QM and MM region,default=1.0
            scale_factor3 (float) (optional): Scale factor for torsions, default=1.0
            num_atoms (int): Number of atoms in the system.
            **kwargs: Additional keyword arguments.
        """
        super().__init__(**kwargs)
        self.functional_high = functional_high
        self.basis_high = basis_high
        self.force_field_high = force_field_high
        self.functional_medium = functional_medium
        self.basis_medium = basis_medium
        self.force_field_medium = force_field_medium
        self.functional_low = functional_low
        self.basis_low = basis_low
        self.force_field_low = force_field_low
        self.high_level_charge = high_level_charge
        self.high_level_multiplicity = high_level_multiplicity
        self.medium_level_charges = medium_level_charge
        self.medium_level_multiplicity = medium_level_multiplicity
        self.low_level_charge = low_level_charge
        self.low_level_multiplicity = low_level_multiplicity
        self.high_level_atoms = high_level_atoms
        self.medium_level_atoms = medium_level_atoms
        self.low_level_atoms = low_level_atoms
        self.bonded_atoms = bonded_atoms
        self.scale_factor1 = scale_factor1
        self.scale_factor2 = scale_factor2
        self.scale_factor3 = scale_factor3
        self.num_atoms = num_atoms
        # If the user only specifies the parameters of two layers, the low-level layer will be omitted

        # populate self.functional and self.basis so that
        # it will not raise errors in parent class
        self.functional = (
            self.functional_high
            or self.functional_medium
            or self.functional_low
        )
        self.basis = self.basis_high or self.basis_medium or self.basis_low

    @property
    def partition_level_strings(self):
        """Obtain the list of partition levels for the atoms in the system."""
        return self._get_partition_levels()

    @property
    def charge_and_multiplicity(self):
        """Obtain charge and multiplicity string."""
        return self._get_charge_and_multiplicity()

    def validate_and_assign_level(
        self, functional, basis, force_field, level_name
    ):
        """Validates functional and basis set for a given level
        and returns formatted theory string.
        Return level of theory if both functional and basis are specified,
        or force field if both are not specified.
        """

        if functional and basis and force_field:
            raise ValueError(
                f"For {level_name} level of theory, one should specify only functional/basis or force field!"
            )

        if force_field:
            assert functional is None and basis is None, (
                f"Force field is given for {level_name} level of theory, "
                f"thus no functional and basis should be given!"
            )
            level_of_theory = force_field
        else:
            # if force field is not given, then functional and basis can be given,
            # so that level of theory takes functional and basis set
            if functional and basis:
                level_of_theory = f"{functional}/{basis}"
            else:
                # but functional and basis set can also not be given, in which case,
                # all 3 are None and overall level of theory for that layer is None.
                level_of_theory = None

        logger.debug(
            f"Obtained level of theory {level_of_theory} for {level_name} level."
        )

        return level_of_theory

    def scale_factor_initialization(self):
        """Initializes scale factors."""
        scale_factor = f"{self.scale_factor1}"
        if self.scale_factor2 is not None:
            scale_factor += f" {self.scale_factor2}"
            if self.scale_factor3 is not None:
                scale_factor += f" {self.scale_factor3}"
        return scale_factor if scale_factor is not None else str(1.0)

    def _get_level_of_theory_string(self):
        """Get ONIOM level of theory for route string."""
        oniom_string = " oniom"
        self.high_level_of_theory = self.validate_and_assign_level(
            self.functional_high,
            self.basis_high,
            self.force_field_high,
            level_name="high",
        )

        self.medium_level_of_theory = self.validate_and_assign_level(
            self.functional_medium,
            self.basis_medium,
            self.force_field_medium,
            level_name="medium",
        )

        self.low_level_of_theory = self.validate_and_assign_level(
            self.functional_low,
            self.basis_low,
            self.force_field_low,
            level_name="low",
        )

        if self.high_level_of_theory is not None:
            oniom_string += f"({self.high_level_of_theory}"
        if self.medium_level_of_theory is not None:
            oniom_string += f":{self.medium_level_of_theory}"
        if self.low_level_of_theory is not None:
            oniom_string += f":{self.low_level_of_theory})"

        return oniom_string

    def _get_partition_levels(self):
        """Obtain the list of partition levels for the atoms in the system.
        Returns:
            list: List of partition levels as strings (H, M, L) for the atoms in the system.
        """
        # convert atom indices to lists if they are not already so
        # for example high_level_atoms=[[18-28], [29-39], [40-50], [51-61], [62-72]],
        # then we want high_level_atoms=[18, 19, 20, ..., 28, 29, 30, ..., 39, ...]
        from chemsmart.utils.utils import get_list_from_string_range

        if self.high_level_atoms and not isinstance(
            self.high_level_atoms, list
        ):
            self.high_level_atoms = get_list_from_string_range(
                self.high_level_atoms
            )
        if self.medium_level_atoms and not isinstance(
            self.medium_level_atoms, list
        ):
            self.medium_level_atoms = get_list_from_string_range(
                self.medium_level_atoms
            )
        if self.low_level_atoms is None:
            # set the rest of the atoms as low level atoms
            default_layer = list(range(1, self.num_atoms + 1))
            medium_level_atoms = (
                self.medium_level_atoms if self.medium_level_atoms else []
            )
            self.low_level_atoms = list(
                set(default_layer)
                - set(medium_level_atoms)
                - set(self.high_level_atoms)
            )
            if self.low_level_atoms and not isinstance(
                self.low_level_atoms, list
            ):
                self.low_level_atoms = get_list_from_string_range(
                    self.low_level_atoms
                )
        return (
            self.high_level_atoms,
            self.medium_level_atoms,
            self.low_level_atoms,
        )

    def _get_charge_and_multiplicity(self):
        """Obtain charge and multiplicity string.
        For two-layer ONIOM jobs, the format for this input line is:

        chrg_real-low spin_real-low [chrg_model-high spin_model-high
                                    [chrg_model-low spin_model-low [chrg_real-high spin_real-high]]]

        Fourth pair applies only to ONIOM=SValue calculations.
        When only a single value pair is specified, all levels will use those values.
        If two pairs of values are included, then third pair defaults to same values as second pair.
        If final pair is omitted for an S-value job, it defaults to values for the real system at low level.

        For 3-layers ONIOM, the format is:
        cRealL sRealL [cIntM sIntM [cIntL sIntL [cModH sModH [cModM sModM [cModL sModL]]]]]
        Real, Int=Intermediate system, and Mod=Model system, and second character
        is one of: H, M and L for the High, Medium and Low levels).
        """
        charge_and_multiplicity = ""
        if (
            self.high_level_charge is not None
            and self.high_level_multiplicity is not None
        ):
            if (
                self.medium_level_multiplicity is None
                and self.medium_level_charges is None
            ):
                charge_and_multiplicity = (
                    f"{self.low_level_charge} {self.low_level_multiplicity} "
                    + f"{self.high_level_charge} {self.high_level_multiplicity} "
                    * 2
                )
            elif (
                self.low_level_charge is None
                and self.low_level_multiplicity is None
            ):
                charge_and_multiplicity = (
                    f"{self.medium_level_charges} {self.medium_level_multiplicity} "
                    + f"{self.high_level_charge} {self.high_level_multiplicity} "
                    * 2
                )
            else:
                charge_and_multiplicity = (
                    f"{self.low_level_charge} {self.low_level_multiplicity} "
                    + f"{self.medium_level_charges} {self.medium_level_multiplicity} "
                    * 2
                    + f"{self.high_level_charge} {self.high_level_multiplicity} "
                    * 3
                )

        return charge_and_multiplicity
